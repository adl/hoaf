#+TITLE: Proposal of an I/O format for omega-automata
#+AUTHOR:

* Goal

Replace =ltl2dstar='s format with something that:
- is more compact when a lot of atomic propositions are used, or when the automaton is not complete
- supports non-deterministic automata
- supports different types of acceptance conditions, preferably in a way that is easy to extend

* Header

Should announce the number of states, the number of atomic
proposition, number of acceptance sets, and the way to use these
acceptance sets.

=ltl2dstar='s first line currently is

: DRA v2 explicit

where (I assume) "explicit" means that transitions are all
explicitly listed.  ltl2dstar's documentation calls this the "edge type"
but does not document any other value than "explicit".

To distinguish from this, I suggest we start with the word OMEGA.  As
in

: OMEGA v3

The other lines of the header are for instance

: States: 2
: Acceptance: 2 (F!0 & I1)
: Start: 0
: AP: 3 "a" "proc@state" "a[x] >= 2"

The order of these lines is the same as in =ltl2dstar='s format.  Do
we want to change it?  I'm always tempted to specify =States:= and
=Start:= together.  Specifying the order probably makes writing the
parser easier (although Spot's parser can already handle the header
lines of =ltl2dstar= in any order).

=States:= specify the number $n$ of states (a non-negative integer).

=Start:= gives the initial states, a list of space-separated integers
in $[0,n)$.  Could be empty (especially if $n=0$).

(I don't really like multiple initial states, but they are sometimes
necessary; for instance for tools like Wring that output state-labeled
automata.)

=AP:= gives the number of atomic propositions, followed by the name of
each of these atomic propositions.  These names are double-quoted and
follow the C convention for escaping (i.e., nested double-quotes are
escaped with a backslash).  Atomic propositions are automatically
numbered from left to right, starting at $0$.

=Acceptance:= specifies the number, m, of acceptance sets, followed by a
Boolean formula built using the operators =|= and =&= over atoms of
the form  =Fx=, =F!x=, =Ix=, =I!x=  where:
- =x= is a integer in $[0,m)$ representing an accepting set,
- =!x= represent the complement of that set,
- =F= and =I= specify whether that set should be visited finitely or
  infinitely often.
The =&= operator has priority over =|=, and parentheses may be used for
grouping.

* Example of Acceptance specifications

** Büchi

Simply:

: Acceptance: 1 I0

** Generalized Büchi or co-Büchi

A generalized automaton with three acceptance sets can be defined with:

: Acceptance: 3 I0&I1&I2

This automaton could be complemented without changing its transition
structure by simply complementing the acceptance, giving a generalized
co-Büchi automaton:

: Acceptance: 3 F0|F1|F2

The promise automaton generated by the tableau construction of
=ltl2tgba= could be output with

: Acceptance: 3 I!0 & I!1 & I!2

(Spot actually makes an extra pass at the end of the translation to
complement the acceptance sets in order to obtain the more usual
=I0&I1&I2= acceptance).

** Streett acceptance

Pairs of acceptance sets $\{(L_1,U_1),...,(L_k,U_k)\}$.  A word is
accepted iff for each pair $(L_i,U_i)$ if it visits $L_i$ infinitely
often, then it also visits $U_i$ infinitely often.  Assuming $k=3$ and
numbering these 6 sets from left ($L_1$) to right ($U_3$), this
corresponds to:
: Acceptance: 6 (F0|I1)&(F2|I3)&(F4|I5)

Note that an acceptance set may be used more than once.  For
instance when translating =(GF(a) -> GF(b)) & (GF(b) -> GF(c))=
into a Streett automaton, it would make sense to use:
: Acceptance: 3 (F0|I1)&(F1|I2)

** Rabin acceptance

There are several equivalent presentations of Rabin acceptance.

J. Klein, in =ltl2dstar=, uses pairs $\{(L_1,U_1),...,(L_k,U_k)\}$ where
there should be some pair $(L_i,U_i)$ such that states in $L_i$ are
visited infinitely often, but states in $U_i$ are visited finitely
often.   This is a the complement of the Streett acceptance above:
: Acceptance: 6 (I0&F1)|(I2&F3)|(I4&F5)

K. Löding, in his diploma thesis, uses pairs $\{(E_1,F_1),...,(E_k,F_k)\}$
where $E_i$ should be visited finitely often, and $F_i$ should be visited
infinitely often.  This is just a reordering of the previous pairs:
: Acceptance: 6 (F0&I1)|(F2&I3)|(F4&I5)

S. Krishnan, in his ISAAC'94 paper, uses pairs
$\{(L_1,U_1),...,(L_k,U_k)\}$ such that the set of recurring states of
a an accepting run should intersect $L_i$ and be included in $U_i$,
for some pair $(L_i,U_i)$.  A similar definition is used by Manna and
Pnueli in their "Hierarchy of Temporal Properties" paper.  This
corresponds to:
: Acceptance: 6 (I0&F!1)|(I2&F!3)|(I4&F!5)

Note: mixing stuff from these different papers has always been a pain
to me, because of these different conventions.  For me the first
convention is the more natural, because it really dualizes my
interpretation of the Streett acceptance (as a strong fairness
property).  Fortunately, our notation should accommodate everybody.

** Generalized Rabin acceptance

Something like $\{(\{L_{11},L_{12},L_{13}\}, U_1), (\{L_{21},L_{22}\},
U_2)\}$, where a run is accepting if there exist some $i$ such that
the run visits infinitely often all the sets $L_{ij}$ and finitely
often the set $U_i$, can be specified with:
: Acceptance: 7 (I0&I1&I2&F3)|(I4&I5&U6)

** Parity Automata

If we want the smallest number of acceptance set that is visited
infinitely often to be even, we can write:
: Acceptance 5 I0 | (F0&F1&I2) | (F0&F1&F2&F3&I4)
or
: Acceptance 5 I0 | F0&F1&(I2 | F2&F3&I4)

* Structure of the automaton

The header is separated from the rest of the structure with =---=.

States should be numbered from $0$ to $n-1$ an specified with the
following grammar

: states           ::=  (state-name edges)*
: // the optional dstring can be used to name the state for
: // cosmetic or debugging purposes, as in ltl2dstar's format
: state-name       ::=  "State:" INT DSTRING? label? acc-sig?
: acc-sig          ::=  "{" INT* "}"
: edges            ::= edge*
: edge             ::= label? INT acc-sig?
: label            ::= "(" label-expr ")"
: label-expr       ::= "t" | "f" | INT | "!" label-expr
:                      | "(" label-expr ")"
:                      | label-expr "&" label-expr
:                      | label-expr "|" label-expr
: dstring          ::= <C-style double-quoted string>
: int              ::= <nonegative integer>

The =INT= occurring in the =state-name= rule is the number of this
state (state should be declared in order from $0$ to $n-1$ so strictly
speaking this number is not necessary).  The =INT= occurring in the
=edge= rule represent the destination state.

The =INT*= used in =acc-sig= represent the acceptance set the
state or edge belongs to.  The =INT=

Finally the =INT= used in =label-expr= denote atomic propositions,
numbered in the order listed on the =AP:= line.

If a state has a label, no outgoing edges of this state should have a
label: this should be used to represent state-labeled automata.

If an edge has a label, all edges of this state should have
a label.

If one state has no label, and no labeled edges, then there
should be exactly $2^a$ edges listed, where $a$ is the number of
atomic propositions.  In this case, each edge corresponds to a
transition, with the same order as in =ltl2dstar=.

* Comments & New lines

The following features might be disputable.  Please give your opinion.

Comments may be introduced between any token by enclosing them with
=/*= and =*/= (with proper nesting, i.e.  =/*a/*b*/c*/=  is one
comment).  This can be used to add additional information (e.g.
debugging data) to the output.

New lines should be considered like any other white space characters: as
token separators.  All the examples below should work even after
newlines have been removed or moved around.  This typically happens if
you copy/paste an automaton into a mailer that reformats paragraphs.

* Examples

** Transition-based Rabin acceptance and explicit labels

: OMEGA v3
: States: 2
: Acceptance: 2 (F0 | I1)
: Start: 0
: AP: 2 "a" "b"
: ---
: State: 0 "a U b"   /* An example of named state */
:   (0 & !1) 0 {0}
:   (1) 1 {0}
: State: 1
:   (t) 1 {1}

** State-based Rabin acceptance and implicit labels

Because of implicit labels, the automaton necessarily has to be complete.

: OMEGA v3
: States: 3
: Acceptance: 2 (F0 | I1)
: Start: 0
: AP: 2 "a" "b"
: ---
: State: 0 "a U b" { 0 }
:   2  /* !a  & !b &/
:   0  /*  a  & !b &/
:   1  /* !a  &  b &/
:   1  /*  a  &  b &/
: State: 1 { 1 }
:   1 1 1 1       /* four transitions on one line */
: State: 2 "sink state" { 0 }
:   2 2 2 2

** TGBA with implicit labels

: OMEGA v3 /* GFa & GFb */
: States: 1 Start: 0
: Acceptance: 2 (I0 & I1)
: Start: 0
: AP: 2 "a" "b"
: ---
: State: 0
:   0       /* !a  & !b &/
:   0 {0}   /*  a  & !b &/
:   0 {1}   /* !a  &  b &/
:   0 {0 1} /*  a  &  b &/

** TGBA with explicit labels

: OMEGA v3 /* GFa & GFb */
: States: 1 Start: 0
: Acceptance: 2 (I0 & I1)
: Start: 0
: AP: 2 "a" "b"
: ---
: State: 0
: (!0 & !1) 0
: (0 & !1)  0 {0}
: (!0 & 1)  0 {1}
: (0 & 1)   0 {0 1}

** Non-deterministic State-based Büchi automaton (à la Wring)

Encoding =GFa= using state labels requires multiple initial states.

: OMEGA v3 /* GFa */
: States: 2
: Acceptance: 1 I0
: Start: 0 1
: AP: 1 "a"
: ---
: State: 0 (0)
:   0 1
: State: 1 (!0) {0}
:   0 1


I have absolutely no intention to represent state-labeled automata
with multiple initial states in Spot, so if I had to read such an
automaton, I would immediately convert it into the following TGBA,
with a new initial state representing the union of two original
states, and pushing everything (label and acceptance) on the outgoing
transitions:

: OMEGA v3
: States: 3
: Acceptance: 1 I0
: Start: 0
: AP: 1 "a"
: ---
: State: 0
:  (!0) 1
:  (0)  2
: State: 1  /* former state 0 */
:  (0) 1
:  (0) 2
: State: 2  /* former state 1 */
:  (!0) 1 {1}
:  (!0) 2 {1}

* Questions

** Weighted automata

Should we make some room for representation of weighted omega-automata?

We could have some optional header
: Weights: ...
that somehow describes the semi-ring used for weights.

And allow initial weight to be specified with something like:
: Start: 0 [0.2] 1 [0.3]
and transitions could have weights
:  (!0 & 1) 1 [0.2] {1}
:  (0 & !1) 0 [0.5] {1 2}

** Alternating automata

Since some of our tools handle alternating automata, wouldn't it make
sense to support those as well?

Note sure how to announce that the automaton will be alternating in
the header, but we can easily allow multiple destination states by
using a Boolean combination (or only a conjunct?) of destination
states.

: State: 1 {1}
:  (!0 & 1) 1&2
:  (0 & !1) 0&1

This would also extend to alternating automata with transition-based
acceptance.
