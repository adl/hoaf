<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="generator" content="pandoc" />
  <title>The Hanoi Omega-Automata Format - </title>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
  <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="TOC">
<div id="TOCTXT">Table of Contents</div>
<ul>
<li><a href="#the-hanoi-omega-automata-format">The Hanoi Omega-Automata Format</a><ul>
<li><a href="#current-status">Current status</a></li>
<li><a href="#goals">Goals</a></li>
<li><a href="#supported-types-of-omega-automata">Supported Types of Omega-Automata</a></li>
<li><a href="#preliminary-notes">Preliminary Notes</a></li>
<li><a href="#common-tokens">Common Tokens</a></li>
<li><a href="#general-layout">General Layout</a></li>
<li><a href="#header">Header</a><ul>
<li><a href="#hoa"><code>HOA:</code></a></li>
<li><a href="#states"><code>States:</code></a></li>
<li><a href="#start"><code>Start:</code></a></li>
<li><a href="#ap"><code>AP:</code></a></li>
<li><a href="#alias"><code>Alias:</code></a></li>
<li><a href="#acceptance"><code>Acceptance:</code></a></li>
<li><a href="#acc-name"><code>acc-name:</code></a></li>
<li><a href="#tool-and-name"><code>tool:</code> and <code>name:</code></a></li>
<li><a href="#properties"><code>properties:</code></a></li>
</ul></li>
<li><a href="#canonical-acceptance-specifications-for-classical-conditions">Canonical acceptance specifications for classical conditions</a><ul>
<li><a href="#buchi-or-co-buchi">Büchi or co-Büchi</a></li>
<li><a href="#generalized-buchi-or-generalized-co-buchi">Generalized Büchi or generalized co-Büchi</a></li>
<li><a href="#streett-acceptance">Streett acceptance</a></li>
<li><a href="#rabin-acceptance">Rabin acceptance</a></li>
<li><a href="#generalized-rabin-acceptance">Generalized Rabin acceptance</a></li>
<li><a href="#parity-automata">Parity automata</a></li>
<li><a href="#trivial-acceptance-conditions-all-and-none">Trivial acceptance conditions: <code>all</code> and <code>none</code></a></li>
</ul></li>
<li><a href="#other-acceptance-conditions">Other acceptance conditions</a></li>
<li><a href="#body-of-the-automaton">Body of the Automaton</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#transition-based-rabin-acceptance-and-explicit-labels">Transition-based Rabin acceptance and explicit labels</a></li>
<li><a href="#state-based-rabin-acceptance-and-implicit-labels">State-based Rabin acceptance and implicit labels</a></li>
<li><a href="#tgba-with-implicit-labels">TGBA with implicit labels</a></li>
<li><a href="#tgba-with-explicit-labels">TGBA with explicit labels</a></li>
<li><a href="#tgba-with-explicit-labels-using-aliases">TGBA with explicit labels using aliases</a></li>
<li><a href="#non-deterministic-state-based-buchi-automaton-a-la-wring">Non-deterministic State-based Büchi automaton (à la Wring)</a></li>
<li><a href="#mixing-state-based-and-transition-based-acceptance">Mixing state-based and transition-based acceptance</a></li>
<li><a href="#alternating-automata">Alternating automata</a></li>
</ul></li>
<li><a href="#formal-semantics-of-omega-automata">Formal Semantics of Omega-Automata</a></li>
<li><a href="#semantics-for-pure-state-based-acceptance">Semantics for Pure State-Based Acceptance</a></li>
<li><a href="#authors">Authors</a></li>
</ul></li>
</ul>
</div>
<h1 id="the-hanoi-omega-automata-format">The Hanoi Omega-Automata Format</h1>
<p>This document describes the Hanoi Omega-Automata (HOA) format. The name is a reference to the ATVA'13 conference, which was organized in Hanoi, and where the foundations of this format were laid.</p>
<p>The <a href="http://adl.github.io/hoaf/">HTML</a> and <a href="http://adl.github.io/hoaf/hoaf.pdf">PDF</a> versions of this document are updated from <a href="https://github.com/adl/hoaf/">the sources on github</a>.</p>
<p>Current tool support is described on a <a href="http://adl.github.io/hoaf/support.html">separate page</a>.</p>
<p>All the examples shown here can also be <a href="http://adl.github.io/hoaf/examples.html">downloaded separately</a>.</p>
<h2 id="current-status">Current status</h2>
<p>This is version 1 of the format. The document may evolve slightly to clarify some parts and fix typos, but you should expect no major semantic change.</p>
<p>If you see any problem, please <a href="https://github.com/adl/hoaf/issues?state=open">report it on the issue tracker</a>.</p>
<p>Change log:</p>
<ul>
<li>2015-05-26: Clarify the notion of canonical encoding, better support for parity automata with <code>property: colored</code>, and cleaner definition of parity acceptance in corner cases (<a href="https://github.com/adl/hoaf/issues/46">#46</a>)</li>
<li>2015-05-20: More compact canonical encoding for parity acceptance, and canonical encoding for <code>min odd</code> and <code>max even</code>. (<a href="https://github.com/adl/hoaf/issues/42">#42</a> and <a href="https://github.com/adl/hoaf/issues/43">#43</a>)</li>
<li>2015-04-17: Some clarification in case <code>States:</code> is missing. (<a href="https://github.com/adl/hoaf/issues/39">#39</a>)</li>
<li>2015-04-17: Fix transition-based semantics to deal with duplicate transitions. (<a href="https://github.com/adl/hoaf/issues/38">#38</a>)</li>
<li>2015-02-24: Clarify that <code>HEADERNAME</code> may not start with <code>-</code>. (<a href="https://github.com/adl/hoaf/issues/37">#37</a>)</li>
<li>2015-02-06: Version 1 published.</li>
</ul>
<h2 id="goals">Goals</h2>
<p>Design a format, inspired from <a href="http://www.ltl2dstar.de/docs/ltl2dstar.html#output-format-dstar"><code>ltl2dstar</code>'s format</a>, but which:</p>
<ul>
<li>is more compact when a lot of atomic propositions are used, or when the automaton is not complete.</li>
<li>supports non-deterministic and alternating omega-automata.</li>
<li>supports state-labeled omega-automata.</li>
<li>supports different types of acceptance conditions, preferably in a way that is easy to extend.</li>
<li>supports transition-based acceptance.</li>
<li>consider new lines as any other white-space characters, i.e., as token separators. All the examples below should work even after newlines have been removed or moved around (this typically happens if you copy/paste an automaton into a mailer that reformats paragraphs). A use case for not using any newline is when compiling results from experiments into a file, with one automaton per line (and maybe other measurments if that is a CSV file), for easier filtering with line-oriented tools such as grep/cut/sed.</li>
<li>supports streams of omega-automata (i.e., multiple automata can be concatenated together and processed in batch).</li>
</ul>
<h2 id="supported-types-of-omega-automata">Supported Types of Omega-Automata</h2>
<p>The HOA format supports many types of finite automata over infinite words: automata with labels on transitions or labels on states, and with a wide range of acceptance conditions based on states or transitions appearing (in)finitely often in an automaton run. Instead of providing semantics for each supported type of omega-automata, we provide only semantics for the general case of alternating automata with labels on transitions and transition-based accepting conditions. Labels on states and state-based acceptance are formally seen as syntactic sugar (their semantics fully corresponding to the expected one). Automata in HOA format can have multiple initial states.</p>
<h2 id="preliminary-notes">Preliminary Notes</h2>
<p><span class="math">\(\def\AP{\mathit{AP}}\def\B{\mathbb{B}}\def\Fin{\mathsf{Fin}}\def\Inf{\mathsf{Inf}}\)</span>Input alphabets of all considered automata types consist of letters that are subsets of atomic propositions (<span class="math">\(\AP\)</span>). To make the automata description more concise, we label states or transitions of automata with Boolean formulas over <span class="math">\(\AP\)</span> representing choices between multiple letters. A Boolean formula represents the set of letters satisfying the formula: a letter satisfies a formula if the valuation assigning True to all atomic propositions in the letter and False to all other atomic propositions is a model of the formula. We use <span class="math">\(\B(\AP)\)</span> to denote the set of Boolean formulas over <span class="math">\(\AP\)</span>.</p>
<p>The format considers acceptance conditions built on a finite set <span class="math">\(\{S_0,S_1,\ldots,S_k\}\)</span> of acceptance sets. Each acceptance set <span class="math">\(S_i\)</span> is a subset of automata states and transitions. Loosely speaking, an acceptance condition says which acceptance sets should be visited infinitely often and which only finitely often by a run to be accepting. More precisely, an acceptance condition is a positive Boolean formula over atoms of the form <span class="math">\(\Fin(S_i)\)</span>, <span class="math">\(\Fin(\lnot S_i)\)</span>, <span class="math">\(\Inf(S_i)\)</span>, or <span class="math">\(\Inf(\lnot S_i)\)</span>. The atom <span class="math">\(\Fin(S_i)\)</span> indicates that all states and transitions in <span class="math">\(S_i\)</span> should occur at most finitely often in the run, while <span class="math">\(\Inf(S_i)\)</span> denotes that some state or transition of <span class="math">\(S_i\)</span> should be visited infinitely often. A state in an acceptance set is formally seen as an abbreviation for inclusion of all transitions leaving the state. The negation symbol <span class="math">\(\lnot\)</span> represents the complement of the set with respect to all transitions. Many examples of classical acceptance conditions (Büchi, Rabin, Streett, parity) will be given later.</p>
<p>The format has a common approach to atomic propositions, states, and acceptance sets: the number of propositions/states/sets, say <span class="math">\(n\)</span>, is first declared and all propositions/states/sets are then referenced as <span class="math">\(0,1,\ldots,n-1\)</span>.</p>
<h2 id="common-tokens">Common Tokens</h2>
<ul>
<li><p><code>STRING</code>: a C-like double-quoted string <code>&quot;(\\.|[^\\&quot;])*&quot;</code></p></li>
<li><p><code>INT</code>: <code>0|[1-9][0-9]*</code><br /> A non-negative integer less than <span class="math">\(2^{31}\)</span> written in base 10 (with no useless <code>0</code> at the beginning).</p></li>
<li><p>comments: <code>/* … */</code><br /> Comments may be introduced between any token by enclosing them with <code>/*</code> and <code>*/</code> (with proper nesting, i.e. <code>/*a/*b*/c*/</code> is one comment). C++-style comments are not considered because they require newlines. Tools can use comments to output additional information (e.g. debugging data) that should be discarded upon reading.</p></li>
<li><p>whitespace: <code>[ \t\n\r]</code><br /> Except in double-quoted strings and comments, whitespace is used only for tokenization and can be discarded afterwards.</p></li>
<li><p><code>BOOLEAN</code>: <code>[tf]</code><br /> The true and false Boolean constants.</p></li>
<li><p><code>IDENTIFIER</code>: <code>[a-zA-Z_][0-9a-zA-Z_-]*</code><br /> An identifier made of letters, digits, <code>-</code> and <code>_</code>. Digits and <code>-</code> may not by used as first character, and <code>t</code> or <code>f</code> are not valid identifiers.</p></li>
<li><p><code>ANAME</code>: <code>@[0-9a-zA-Z_-]+</code><br /> An alias name, i.e., &quot;@&quot; followed by some alphanumeric characters, <code>-</code> or <code>_</code>. These are used to identify atomic propositions or subformulas.</p></li>
<li><p><code>HEADERNAME</code>: <code>[a-zA-Z_][0-9a-zA-Z_-]*:</code><br /> Header names are similar to identifiers, except that they are immediately followed by a colon (i.e. no comment or space allowed). If an <code>IDENTIFIER</code> or a <code>BOOLEAN</code> is immediately followed by a colon, it should be considered as a <code>HEADERNAME</code>.</p></li>
</ul>
<h2 id="general-layout">General Layout</h2>
<p>This format is designed so that we can write tools that can process automata in batch. A tool could for instance get a stream of automata descriptions concatenated together as input and process these to output another stream of automata.</p>
<p>Every automaton is described in two parts: a header, that supplies meta-data about the automaton (such as number of states and acceptance condition), and a body, encoding the automaton as a labeled graph.<br />The two parts are separated by <code>--BODY--</code>. The token <code>--END--</code> marks the end of the automaton.</p>
<pre><code>automaton ::= header &quot;--BODY--&quot; body &quot;--END--&quot;</code></pre>
<p>Additionally, the <code>--ABORT--</code> token may be used after any token of this grammar (even in the header) to indicate that the produced automaton should be discarded, for instance in case an error condition is detected during output. In a streaming scenario, a new automaton can start immediately after such an <code>--ABORT--</code> token. Note that <code>foo--ABORT--</code> is a valid identifier and shall not abort streaming: to ensure proper tokenization always add a space or newline before <code>--ABORT--</code> to abort the output.</p>
<h2 id="header">Header</h2>
<pre><code>header ::= format-version header-item*
format-version ::= &quot;HOA:&quot; IDENTIFIER
header-item ::= &quot;States:&quot; INT
             | &quot;Start:&quot; state-conj
             | &quot;AP:&quot; INT STRING*
             | &quot;Alias:&quot; ANAME label-expr
             | &quot;Acceptance:&quot; INT acceptance-cond
             | &quot;acc-name:&quot; IDENTIFIER (BOOLEAN|INT|IDENTIFIER)*
             | &quot;tool:&quot; STRING STRING?
             | &quot;name:&quot; STRING
             | &quot;properties:&quot; IDENTIFIER*
             | HEADERNAME (BOOLEAN|INT|STRING|IDENTIFIER)*</code></pre>
<p>The header is a list of <code>header-item</code>s (a <code>HEADERNAME</code> followed by some data). Except for the &quot;HOA:&quot; item, which should always come first, the items may occur in any order. Some <code>HEADERNAME</code>s have predefined semantics (and might be mandatory) as specified below. This format also makes provision of additional (unspecified) header names to be used.</p>
<p>Any given <code>HEADERNAME</code> should occur at most once, except for <code>Start:</code>, <code>Alias:</code>, and <code>properties:</code>. The case of the <code>HEADERNAME</code>'s initial is used to specify whether tools may safely ignore a header item they do not support: header items whose name start with an upper-case letter are expected to influence the semantic of the automaton: tools should at least warn about any such <code>HEADERNAME</code> they do not understand. A <code>HEADERNAME</code> whose initial is lowercase may be safely ignored without affecting the semantics.</p>
<p>Headers items <code>HOA:</code>, and <code>Acceptance:</code> must always be present.</p>
<h3 id="hoa"><code>HOA:</code></h3>
<p><code>HOA:</code> should always be the first token of the file. It is followed by an identifier that represents the version of the format. This document specifies the first version of this format so this header should appear as</p>
<pre><code>HOA: v1</code></pre>
<h3 id="states"><code>States:</code></h3>
<p>This optionnal header item specifies the number of states in the automaton.</p>
<p>The states are assumed to be numbered consecutively from 0. For instance:</p>
<pre><code>States: 10</code></pre>
<p>specifies an automaton with 10 states numbered from 0 to 9.</p>
<p>An empty automaton, with no states, can be specified with <code>States: 0</code>.</p>
<p>It is recommended to specify the number of states whenever possible, so that readers may preallocate data structures and perform better error checking. Cases where <code>States:</code> could be missing are typically those where an automaton is constructed on-the-fly during its output, and the actual number of states is unknown before the end of the output.</p>
<h3 id="start"><code>Start:</code></h3>
<p>This optional header item specifies the initial states. Multiple initial states can be specified by using several <code>Start:</code> headers with a different state number.</p>
<p>Alternating automata can start in a conjunction of states specified using the <code>&amp;</code> operator.</p>
<pre><code>header-item ::= … | &quot;Start:&quot; state-conj
state-conj ::= INT | state-conj &quot;&amp;&quot; INT</code></pre>
<p>If the <code>Start:</code> header item is omitted, then the automaton has no initial state and denotes an empty language.</p>
<h3 id="ap"><code>AP:</code></h3>
<p><code>AP:</code> gives the number of atomic propositions, followed by unique names for each of these atomic propositions (using double-quoted C-strings). Atomic propositions are implicitly numbered from left to right, starting at 0.</p>
<p>For instance</p>
<pre><code>AP: 3 &quot;a&quot; &quot;proc@state&quot; &quot;a[x] &gt;= 2&quot;</code></pre>
<p>specifies three atomic propositions:</p>
<ul>
<li>atomic proposition 0 is <code>&quot;a&quot;</code></li>
<li>atomic proposition 1 is <code>&quot;proc@state&quot;</code></li>
<li>atomic proposition 2 is <code>&quot;a[x] &gt;= 2&quot;</code></li>
</ul>
<p>The number of double-quoted strings must match exactly the number given, and should all be different. This number may be 0, in which case it is not followed by any string, and this is equivalent to not using <code>AP:</code>.</p>
<h3 id="alias"><code>Alias:</code></h3>
<p>Aliases are used to name atomic propositions or common subformulas that will be used later as labels in the automaton. This format can be used without any aliases, refering to atomic propositions by their numbers. Naming atomic propositions using aliases can make the automaton more readable to the human, and naming subformulas that are used repeatedly can help making the output more concise.</p>
<pre><code>headeritem ::= … | &quot;Alias:&quot; ANAME label-expr
label-expr ::= BOOLEAN | INT | ANAME | &quot;!&quot; label-expr
             | &quot;(&quot; label-expr &quot;)&quot;
             | label-expr &quot;&amp;&quot; label-expr
             | label-expr &quot;|&quot; label-expr</code></pre>
<p>The <code>label-expr</code> will also be used to label transitions in automata. <code>INT</code> refers to an atomic proposition number (as specified on the <code>AP:</code> line), <code>ANAME</code> refers to a previously defined alias, and <code>BOOLEAN</code> are the Boolean values (<code>t</code> or <code>f</code>). The <code>Alias:</code> line may appear multiple times, but it is forbidden to redefine an alias. The <code>!</code> operator has priority over <code>&amp;</code> which in turn has priority over <code>|</code>. Parentheses may be used for grouping.</p>
<p>Here are some examples of aliases:</p>
<pre><code>AP: 3 &quot;a&quot; &quot;proc@state&quot; &quot;a[x] &gt;= 2&quot;
Alias: @a 0
Alias: @ps 1
Alias: @a2 2
Alias: @c @ps|@a2</code></pre>
<p>The first three aliases are just mnemonic names for the atomic propositions, while the last one replace some arbitrary subformula. Defining <code>@c</code> before the definition of <code>@ps</code> and <code>@a2</code> would be incorrect.</p>
<h3 id="acceptance"><code>Acceptance:</code></h3>
<pre><code>header-item ::= … | &quot;Acceptance:&quot; INT acceptance-cond

acceptance-cond ::= IDENTIFIER &quot;(&quot; &quot;!&quot;? INT &quot;)&quot;
                 | &quot;(&quot; acceptance-cond &quot;)&quot;
                 | acceptance-cond &quot;&amp;&quot; acceptance-cond
                 | acceptance-cond &quot;|&quot; acceptance-cond
                 | BOOLEAN</code></pre>
<p>The mandatory <code>Acceptance:</code> header item is used to specify the number of acceptance sets used by the automaton and how these acceptance sets are combined in the acceptance condition. If <span class="math">\(m\)</span> sets are declared, these sets are numbered from <span class="math">\(0\)</span> to <span class="math">\(m-1\)</span>. In this version of the format, the <code>IDENTIFIER</code> used in <code>acceptance-cond</code> can only be <code>Fin</code> or <code>Inf</code>.</p>
<p>The acceptance condition is specified as a positive Boolean combination of expressions of the form <code>Fin(x)</code>, <code>Fin(!x)</code>, <code>Inf(x)</code>, and <code>Inf(!x)</code> where:</p>
<ul>
<li><code>x</code> is an integer in <span class="math">\([0,m)\)</span> representing an accepting set,</li>
<li><code>!x</code> represents the complement of that set,</li>
<li><code>Fin(x)</code> and <code>Inf(x)</code> specify whether that set should be visited finitely or infinitely often.</li>
</ul>
<p>The <code>&amp;</code> operator has priority over <code>|</code>, and parentheses may be used for grouping.</p>
<p>Additionally the <code>t</code> and <code>f</code> Boolean constants can be used with their obvious meanings (<code>t</code> is always accepting while <code>f</code> is never accepting).</p>
<p>As explained previously, our semantics for acceptance are transition-based, so if an automaton uses both accepting states and accepting transitions, the acceptance of the states should be transferred to their outgoing transitions so that complementation of acceptance sets can be performed with respect to all transitions.</p>
<p>For instance</p>
<pre><code>Acceptance: 2 Fin(!0) &amp; Inf(1)</code></pre>
<p>declares two acceptance sets. A run of the automaton is accepting if it visits the complement of the first set finitely often, and if it visits the second set infinitely often. More examples will be given in a later section.</p>
<p>An acceptance condition declaring <span class="math">\(m\)</span> sets needs not actually use all of these sets. In this case the unused sets can be ignored if they appear in the body of the automaton.</p>
<h3 id="acc-name"><code>acc-name:</code></h3>
<pre><code>header-item ::= … | &quot;acc-name:&quot; IDENTIFIER (IDENTIFIER | INT)*</code></pre>
<p>This optional header item gives a symbolic name to the acceptance conditions specified by the mandatory <code>Acceptance:</code> header item.</p>
<p>The first <code>IDENTIFIER</code> is a name, and the remaining <code>IDENTIFIER</code>s and <code>INT</code>s are parameters. The following acceptance names are fully specified in a later section:</p>
<ul>
<li><code>Buchi</code></li>
<li><code>generalized-Buchi</code></li>
<li><code>co-Buchi</code></li>
<li><code>generalized-co-Buchi</code></li>
<li><code>Streett</code></li>
<li><code>Rabin</code></li>
<li><code>generalized-Rabin</code></li>
<li><code>parity</code></li>
<li><code>all</code></li>
<li><code>none</code></li>
</ul>
<p>Additional (unspecified) acceptance names may be used when needed.</p>
<h3 id="tool-and-name"><code>tool:</code> and <code>name:</code></h3>
<pre><code>header-item ::= …
             | &quot;tool:&quot; STRING STRING?
             | &quot;name:&quot; STRING</code></pre>
<p>These optional header items can be used to record information about the tool used to produce the automaton, or to give a name to this automaton. The two arguments of <code>tool:</code> corresponds respectively to the tool's name and its (optional) version number.</p>
<p>For instance:</p>
<pre><code>tool: &quot;ltl-translate&quot; &quot;1.2-alpha&quot;
name: &quot;BA for GFa &amp; GFb&quot;</code></pre>
<h3 id="properties"><code>properties:</code></h3>
<pre><code>header-item ::= … | &quot;properties:&quot; IDENTIFIER*</code></pre>
<p>The optional <code>properties:</code> header name can be followed by a list of identifiers that gives additional information about the automaton. Multiple <code>properties:</code> lines can be used, it has the same effect as listing all properties on one line. This information should be redundant in the sense that ignoring them should not impact the behavior of the automaton. For instance stating that an automaton is deterministic with</p>
<pre><code>properties: deterministic</code></pre>
<p>may enable tools that read the automaton to choose a better data structure to store this automaton, but ignoring this header item will not suddenly make the automaton non-deterministic.</p>
<p>The following properties have specified meanings, but additional may be added, and tools may simply ignore those they do not know:</p>
<ul>
<li><code>state-labels</code> hints that the automaton uses only state labels</li>
<li><code>trans-labels</code> hints that the automaton uses only transition labels</li>
<li><code>implicit-labels</code> hints that the automaton uses only implicit transitions labels</li>
<li><code>explicit-labels</code> hints that the automaton uses only explicit transitions labels</li>
<li><code>state-acc</code> hints that the automaton uses only state-based acceptance specifications</li>
<li><code>trans-acc</code> hints that the automaton uses only transition-based acceptance specifications</li>
<li><code>univ-branch</code> hints that the automaton uses universal branching for at least one transition or for the initial state</li>
<li><code>no-univ-branch</code> hints that the automaton does not uses universal branching</li>
<li><code>deterministic</code> hints that the automaton is deterministic, i.e., it has at most one initial state, and the outgoing transitions of each state have disjoint labels (note that this also applies in the presence of universal branching)</li>
<li><code>complete</code> hints that the automaton is complete, i.e., it has at least one state, and the transition function is total</li>
<li><code>unambiguous</code> hints that the automaton is unambiguous, i.e., for each word there is at most one accepting run of the automaton (this also applies in the presence of universal branching)</li>
<li><code>stutter-invariant</code> hints that the automaton describes a <a href="http://dx.doi.org/10.1007/3-540-48683-6_22">stutter-invariant</a> property</li>
<li><code>weak</code> hints that in each strongly connected component (in alternating automata, SCC can be defined in standard way if we see each universal branching transition as a set of non-branching transitions), all transitions (or all states) belong to the same accepting sets</li>
<li><code>very-weak</code> hints that the automaton is weak and every SCC has exactly one state</li>
<li><code>inherently-weak</code> hints that the automaton does not mix accepting cycles and non-accepting cycles in the same SCC</li>
<li><code>terminal</code> hints that the automaton is weak, that no non-accepting cycle can be reached from any accepting cycle, and that each SCC containing an accepting cycle is complete, i.e., the transition function is definied for each state of the SCC and each letter</li>
<li><code>tight</code> hints that the automaton is <a href="http://dx.doi.org/10.1007/978-3-540-31980-1_32">tight</a>, i.e. for every word <span class="math">\(w=a_0a_1\ldots\)</span> accepted by the automaton there exists an accepting run over <span class="math">\(w\)</span> such that whenever two suffixes <span class="math">\(w_i=a_ia_{i+1}\ldots\)</span> and <span class="math">\(w_j=a_ja_{j+1}\ldots\)</span> of <span class="math">\(w\)</span> are identical, the run reaches identical states (or sets of the states in the case of alternating automaton) by reading the corresponding prefixes <span class="math">\(a_0\ldots a_{i-1}\)</span> and <span class="math">\(a_0\ldots a_{j-1}\)</span></li>
<li><code>colored</code> hints that each transition (or each state, for state-based acceptance) of the automaton belongs to exactly one acceptance set; this is typically the case in parity automata</li>
</ul>
<p>Note that even if some property implies another one (for instance <code>explicit-labels</code> implies <code>trans-labels</code>) it is recommended to specify both.</p>
<h2 id="canonical-acceptance-specifications-for-classical-conditions">Canonical acceptance specifications for classical conditions</h2>
<p>The <code>Acceptance:</code> line is what defines the acceptance semantics of the automaton and the <code>acc-name:</code> has only informative value. However, tools that do not want to implement a parser for the <code>Acceptance:</code> line may decide to only support input HOA file that carry an <code>acc-name:</code> they support. To avoid surprises, when the <code>acc-name:</code> line is used, the mandatory <code>Acceptance:</code> line should match exactly the canonical acceptance formulas given in the following examples.</p>
<p>Note that the order of the terms in the canonical acceptance formulas matters even though the Boolean operators are commutative and associative (e.g., <code>acc-name: Rabin 1</code> corresponds to <code>Fin(0)&amp;Inf(1)</code> but not <code>Inf(1)&amp;Fin(0)</code>). This restriction makes it easier to detect potential mismatches between <code>acc-name:</code> and <code>Acceptance:</code>.</p>
<p>Some of the examples below use <code>Acceptance:</code> specifications for which there are no <code>acc-name:</code> defined.</p>
<h3 id="buchi-or-co-buchi">Büchi or co-Büchi</h3>
<p>Those acceptance conditions are specified with</p>
<pre><code>acc-name: Buchi
Acceptance: 1 Inf(0)</code></pre>
<p>or</p>
<pre><code>acc-name: co-Buchi
Acceptance: 1 Fin(0)</code></pre>
<h3 id="generalized-buchi-or-generalized-co-buchi">Generalized Büchi or generalized co-Büchi</h3>
<p>A generalized Büchi automaton with three acceptance sets can be defined with:</p>
<pre><code>acc-name: generalized-Buchi 3
Acceptance: 3 Inf(0)&amp;Inf(1)&amp;Inf(2)</code></pre>
<p>A deterministic automaton with such an acceptance condition could be complemented without changing its transition structure by simply complementing the acceptance, giving a generalized co-Büchi automaton:</p>
<pre><code>acc-name: generalized-co-Buchi 3
Acceptance: 3 Fin(0)|Fin(1)|Fin(2)</code></pre>
<h3 id="streett-acceptance">Streett acceptance</h3>
<p>Pairs of acceptance sets <span class="math">\(\{(L_1,U_1),\ldots,(L_k,U_k)\}\)</span>. A run is accepting for a pair <span class="math">\((L_i,U_i)\)</span> iff the run visiting <span class="math">\(L_i\)</span> infinitely often implies that the run also visits <span class="math">\(U_i\)</span> infinitely often. A run is accepting iff it is accepting for all pairs. Assuming <span class="math">\(k=3\)</span> and numbering these 6 sets from left (<span class="math">\(L_1\)</span>) to right (<span class="math">\(U_3\)</span>), this corresponds to:</p>
<pre><code>acc-name: Streett 3
Acceptance: 6 (Fin(0)|Inf(1))&amp;(Fin(2)|Inf(3))&amp;(Fin(4)|Inf(5))</code></pre>
<p>The parameter <code>3</code> in <code>acc-name: Streett 3</code> refers to the number of Streett pairs.</p>
<h3 id="rabin-acceptance">Rabin acceptance</h3>
<p>There are several equivalent presentations of Rabin acceptance, and working with tools that use different definitions is often a source of confusion. Our notations of the acceptance condition accommodate all styles, while giving clear and unambiguous semantics.</p>
<p>J. Klein, in <a href="http://www.ltl2dstar.de/docs/ltl2dstar.html#dra_dsa"><code>ltl2dstar</code></a>, uses pairs <span class="math">\(\{(L_1,U_1),\ldots,(L_k,U_k)\}\)</span> where there should be some pair <span class="math">\((L_i,U_i)\)</span> such that states in <span class="math">\(L_i\)</span> are visited infinitely often, but states in <span class="math">\(U_i\)</span> are visited finitely often. This is simply the complement of the Streett acceptance above:</p>
<pre><code>Acceptance: 6 (Inf(0)&amp;Fin(1))|(Inf(2)&amp;Fin(3))|(Inf(4)&amp;Fin(5))</code></pre>
<p>C. Löding, in <a href="http://automata.rwth-aachen.de/~loeding/diploma_loeding.pdf">his diploma thesis</a>, uses pairs <span class="math">\(\{(E_1,F_1),\ldots,(E_k,F_k)\}\)</span> where <span class="math">\(E_i\)</span> should be visited finitely often, and <span class="math">\(F_i\)</span> should be visited infinitely often. This is just a reordering of the previous pairs:</p>
<pre><code>acc-name: Rabin 3
Acceptance: 6 (Fin(0)&amp;Inf(1))|(Fin(2)&amp;Inf(3))|(Fin(4)&amp;Inf(5))</code></pre>
<p>The parameter <code>3</code> in <code>acc-name: Rabin 3</code> refers to the number of Rabin pairs.<br />The reason this definition was choosen for <code>acc-name: Rabin</code> is that is seems to be the most commonly used.</p>
<p>S. Krishnan, in <a href="http://dx.doi.org/10.1007/3-540-58325-4_202">his ISAAC'94 paper</a>, uses pairs <span class="math">\(\{(L_1,U_1),\ldots,(L_k,U_k)\}\)</span> such that the set of recurring states of a an accepting run should intersect <span class="math">\(L_i\)</span> and be included in <span class="math">\(U_i\)</span>, for some pair <span class="math">\((L_i,U_i)\)</span>. A similar definition is used by Manna and Pnueli in their &quot;Hierarchy of Temporal Properties&quot; paper. This corresponds to:</p>
<pre><code>Acceptance: 6 (Inf(0)&amp;Fin(!1))|(Inf(2)&amp;Fin(!3))|(Inf(4)&amp;Fin(!5))</code></pre>
<h3 id="generalized-rabin-acceptance">Generalized Rabin acceptance</h3>
<p>Rabin acceptance has been generalized in works by <a href="http://arxiv.org/abs/1204.5057">Křetínský &amp; Esparza</a> or <a href="http://dx.doi.org/10.1007/978-3-319-02444-8_4">Babiak et al.</a>. They both translate LTL formulas into generalized Rabin automata in which the acceptance condition may look like <span class="math">\(\{(E_1,\{F_{11},F_{12},F_{13}\}), (E_2,\{F_{21},F_{22}\})\}\)</span>, and where a run is accepting if there exists some i such that the run visits finitely often the set <span class="math">\(E_i\)</span> and infinitely often all the sets <span class="math">\(F_{ij}\)</span>. Such an acceptance condition can be specified with:</p>
<pre><code>acc-name: generalized-Rabin 2 3 2
Acceptance: 7 (Fin(0)&amp;Inf(1)&amp;Inf(2)&amp;Inf(3))|(Fin(4)&amp;Inf(5)&amp;Inf(6))</code></pre>
<p>The first parameter of <code>generalized-Rabin</code> gives the number of generalized pairs and the following parameters give the number of <span class="math">\(F_{ij}\)</span> sets in the corresponding pairs.</p>
<h3 id="parity-automata">Parity automata</h3>
<p>For parity acceptance, <code>acc-name: parity</code> has three parameters to support combinations of <code>min</code>/<code>max</code> and <code>even</code>/<code>odd</code>, and to specify the range of acceptance sets used. In an automaton with <code>max odd</code> parity acceptance, for instance, a run is accepting if the maximum set number visited infinitely often along the run is odd.</p>
<p>A typical parity automaton should have <code>property: colored</code>, ensuring that each transition (or state) belongs to exactly one acceptance set. In this context the maximum or minimum set number seen infinitely often along a run always exists.</p>
<p>The canonical encodings for parity acceptance have been chosen so they behave nicely even in automata where <code>property: colored</code> does not hold, i.e., where some transitions (or states) may belong to multiple acceptance sets or none. In particular if <span class="math">\(F\)</span> is the set of numbers of the acceptance sets visited infinitely often by a run of an automaton with <span class="math">\(n\)</span> acceptance sets, we assume that <span class="math">\(\min(\emptyset\)</span>)=n$ and <span class="math">\(\max(\emptyset)=-1\)</span> for the purpose of deciding the parity of <span class="math">\(\min(F)\)</span> or <span class="math">\(\max(F)\)</span>.</p>
<p>Here are the first instances of the <code>min odd</code> condition for different numbers of sets:</p>
<pre><code>acc-name: parity min odd 0
Acceptance: 0 f

acc-name: parity min odd 1
Acceptance: 1 Fin(0)

acc-name: parity min odd 2
Acceptance: 2 Fin(0) &amp; Inf(1)

acc-name: parity min odd 3
Acceptance: 3 Fin(0) &amp; (Inf(1) | Fin(2))

acc-name: parity min odd 4
Acceptance: 4 Fin(0) &amp; (Inf(1) | (Fin(2) &amp; Inf(3)))

acc-name: parity min odd 5
Acceptance: 5 Fin(0) &amp; (Inf(1) | (Fin(2) &amp; (Inf(3) | Fin(4))))</code></pre>
<p>The <code>min even</code> cases are dual:</p>
<pre><code>acc-name: parity min even 0
Acceptance: 0 t

acc-name: parity min even 1
Acceptance: 1 Inf(0)

acc-name: parity min even 2
Acceptance: 2 Inf(0) | Fin(1)

acc-name: parity min even 3
Acceptance: 3 Inf(0) | (Fin(1) &amp; Inf(2))

acc-name: parity min even 4
Acceptance: 4 Inf(0) | (Fin(1) &amp; (Inf(2) | Fin(3)))

acc-name: parity min even 5
Acceptance: 5 Inf(0) | (Fin(1) &amp; (Inf(2) | (Fin(3) &amp; Inf(4)))</code></pre>
<p>The <code>max odd</code> condition is similar to <code>min odd</code>, but encoded in the reverse direction:</p>
<pre><code>acc-name: parity max odd 0
Acceptance: 0 t

acc-name: parity max odd 1
Acceptance: 1 Fin(0)

acc-name: parity max odd 2
Acceptance: 2 Inf(1) | Fin(0)

acc-name: parity max odd 3
Acceptance: 3 Fin(2) &amp; (Inf(1) | Fin(0))

acc-name: parity max odd 4
Acceptance: 4 Inf(3) | (Fin(2) &amp; (Inf(1) | Fin(0)))

acc-name: parity max odd 5
Acceptance: 5 Fin(4) &amp; (Inf(3) | (Fin(2) &amp; (Inf(1) | Fin(0))))</code></pre>
<p>And again <code>max even</code> conditions are dual to <code>max odd</code>:</p>
<pre><code>acc-name: parity max even 0
Acceptance: 0 f

acc-name: parity max even 1
Acceptance: 1 Inf(0)

acc-name: parity max even 2
Acceptance: 2 Fin(1) &amp; Inf(0)

acc-name: parity max even 3
Acceptance: 3 Inf(2) | (Fin(1) &amp; Inf(0))

acc-name: parity max even 4
Acceptance: 4 Fin(3) &amp; (Inf(2) | (Fin(1) &amp; Inf(0)))

acc-name: parity max even 5
Acceptance: 5 Inf(4) | (Fin(3) &amp; (Inf(2) | (Fin(1) &amp; Inf(0))))</code></pre>
<p>Note that in all those acceptance specifications, <code>Inf</code> is always followed by <code>|</code>, <code>Fin</code> is always followed by <code>&amp;</code>, and both are alternating.</p>
<h3 id="trivial-acceptance-conditions-all-and-none">Trivial acceptance conditions: <code>all</code> and <code>none</code></h3>
<p>When <code>generalized-Büchi</code> or <code>Streett</code> are used with <code>0</code> acceptance sets, they degenerate to conditions that accept all recognized words:</p>
<pre><code>acc-name: generalized-Buchi 0
Acceptance: 0 t</code></pre>
<p>or</p>
<pre><code>acc-name: Streett 0
Acceptance: 0 t</code></pre>
<p>We also have similar cases for parity acceptance:</p>
<pre><code>acc-name: parity max odd 0
Acceptance: 0 t

acc-name: parity min even 0
Acceptance: 0 t</code></pre>
<p>Such an all-accepting condition typically occurs when translating safety formulas, or when building monitors. In these specialized cases, it might not really make sense to name the acceptance <code>generalized-Buchi</code> or <code>Streett</code>. For this reason, we also support the name <code>all</code> as a synonym:</p>
<pre><code>acc-name: all
Acceptance: 0 t</code></pre>
<p>Similarly, but less interestingly, <code>generalized-co-Buchi</code> and <code>Rabin</code> all degenerate to <code>f</code> when using 0 acceptance pairs, and this acceptance condition can also be called <code>none</code>. The following acceptance specifications are equivalent and describe automata that will reject all words:</p>
<pre><code>acc-name: generalized-co-Buchi 0
Acceptance: 0 f

acc-name: Rabin 0
Acceptance: 0 f

acc-name: generalized-Rabin 0
Acceptance: 0 f

acc-name: parity max even 0
Acceptance: 0 f

acc-name: parity min odd 0
Acceptance: 0 f

acc-name: none
Acceptance: 0 f</code></pre>
<h2 id="other-acceptance-conditions">Other acceptance conditions</h2>
<p>The HOA format is not restricted to the above classical acceptance conditions. Below are some examples of acceptance conditions for which we define no name for use in <code>acc-name:</code>. Tools should however feel free to introduce new names, should they need them.</p>
<p>A promise automaton generated by the tableau construction of <a href="http://spot.lip6.fr/userdoc/ltl2tgba.html"><code>ltl2tgba</code></a> could be output with:</p>
<pre><code>Acceptance: 3 Inf(!0) &amp; Inf(!1) &amp; Inf(!2)</code></pre>
<p>(Spot actually makes an extra pass at the end of the translation to complement the acceptance sets in order to obtain the more usual generalized Büchi <code>Inf(0)&amp;Inf(1)&amp;Inf(2)</code> acceptance).</p>
<p>The product of a <code>Rabin 2</code> automaton with a <code>Streett 2</code> automaton, performed in a very straightforward way, will have an acceptance condition such as the following, where sets 1-4 are used as Rabin pairs, while sets 4-7 are used as Streett pairs.</p>
<p>Acceptance: 8 ((Inf(0)&amp;Fin(1))|(Inf(2)&amp;Fin(3)))&amp;((Fin(4)|Inf(5))&amp;(Fin(6)|Inf(7)))</p>
<p>Although it is not the case in the classical acceptance conditions, acceptance sets can be used multiple times in the same acceptance formula, possibly even with both <code>Fin</code> and <code>Inf</code> primitives. For instance when translating the LTL formula <code>(GF(a) -&gt; GF(b)) &amp; (GF(b) -&gt; GF(c))</code> into an automaton with Streett-like acceptance, it would make sense to use:</p>
<pre><code>Acceptance: 3 (Fin(0)|Inf(1))&amp;(Fin(1)|Inf(2))</code></pre>
<p>this however does not fit our strict definition of <code>acc-name: Streett 2</code> (which would be <code>Acceptance 4: (Fin(0)|Inf(1))&amp;(Fin(2)|Inf(3))</code>).</p>
<p>Similarly, translating the LTL formulas <code>GF(a) xor GF(b)</code> could easily be done using an automaton with the following acceptance:</p>
<pre><code>Acceptance: 2 (Fin(0)&amp;Inf(1))|(Inf(0)&amp;Fin(1))</code></pre>
<p>Tool authors implementing support for generic acceptance conditions are encouraged to verify that they correctly deal with such cases, in which the same acceptance sets are used both in <code>Fin</code> and <code>Inf</code> primitives.</p>
<h2 id="body-of-the-automaton">Body of the Automaton</h2>
<p>The header is separated from the rest of the structure with <code>--BODY--</code>.</p>
<p>States are specified with the following grammar:</p>
<pre><code>body             ::= (state-name edge*)*
// the optional dstring can be used to name the state for
// cosmetic or debugging purposes, as in ltl2dstar&#39;s format
state-name       ::= &quot;State:&quot; label? INT STRING? acc-sig?
acc-sig          ::= &quot;{&quot; INT* &quot;}&quot;
edge             ::= label? state-conj acc-sig?
label            ::= &quot;[&quot; label-expr &quot;]&quot;</code></pre>
<p>The <code>INT</code> occurring in the <code>state-name</code> rule is the number of this state. States should be numbered from <span class="math">\(0\)</span> to <span class="math">\(n-1\)</span>, where <span class="math">\(n\)</span> is the value given by the <code>States:</code> header item if it is present. If the <code>States:</code> header item is missing, <span class="math">\(n-1\)</span> should be assumed to be the highest state number listed either in the automaton body (either when defining a state, or when used as a destination of a transition) or as some initial state.</p>
<p>States may be listed in any order, but should all be listed (i.e., if the header has <code>States: 10</code> then the body should have ten <code>State: INT</code> statements, with all numbers from 0 to 9). In addition to a number, a state may optionally be given a name (the <code>STRING</code> token) for cosmetic or practical purposes.</p>
<p>The <code>INT*</code> used in <code>acc-sig</code> represent the acceptance sets the state or edge belongs to. Since we use transition-based acceptance, when <code>acc-sig</code> is used on a state to declare membership to some acceptance sets, it is syntactic sugar for the membership of all the outgoing transitions to this set. For instance <code>State: 0 {1 3}</code> would states that all transitions leaving state 0 are in acceptance sets 1 and 3.</p>
<p>The <code>state-conj</code> encodes the destination of an edge as a conjunction of state numbers. Non-alternating automata always use a single state number as destination. These conjunctions makes it possible to encode the universal branching of alternating automata, while disjunction is simply encoded as multiple transitions.</p>
<p>If a state has a <code>label</code>, no outgoing edge of this state should have a <code>label</code>: this should be used to represent state-labeled automata. In our semantics, we have to view this as syntactic sugar for all outgoing transitions being labeled by this very same <code>label</code>.</p>
<p>If an edge has a <code>label</code>, all edges of this state should have a <code>label</code>.</p>
<p>If one state has no <code>label</code>, and no labeled edges, then there should be exactly <span class="math">\(2^a\)</span> edges listed, where <span class="math">\(a\)</span> is the number of atomic propositions. In this case, each edge corresponds to a transition, with the same order as in <code>ltl2dstar</code>. If a transition <span class="math">\(t\)</span> is the <span class="math">\(i\)</span>-th transition of a state (starting with 0), then the label of <span class="math">\(t\)</span> can be deduced by interpreting <span class="math">\(i\)</span> as a bitset. The label is a set of atomic propositions such that the atomic proposition <span class="math">\(j\)</span> is in the set if the <span class="math">\(j\)</span>-th least significant bit of <span class="math">\(i\)</span> is set to 1.</p>
<h2 id="examples">Examples</h2>
<h3 id="transition-based-rabin-acceptance-and-explicit-labels">Transition-based Rabin acceptance and explicit labels</h3>
<p><img src="figures/aut1.svg" alt="automaton" /></p>
<pre><code>HOA: v1
States: 2
Start: 0
acc-name: Rabin 1
Acceptance: 2 (Fin(0) &amp; Inf(1))
AP: 2 &quot;a&quot; &quot;b&quot;
--BODY--
State: 0 &quot;a U b&quot;   /* An example of named state */
  [0 &amp; !1] 0 {0}
  [1] 1 {0}
State: 1
  [t] 1 {1}
--END--</code></pre>
<h3 id="state-based-rabin-acceptance-and-implicit-labels">State-based Rabin acceptance and implicit labels</h3>
<p>Because of implicit labels, the automaton necessarily has to be deterministic and complete.</p>
<p><img src="figures/aut2.svg" alt="automaton" /></p>
<pre><code>HOA: v1
States: 3
Start: 0
acc-name: Rabin 1
Acceptance: 2 (Fin(0) &amp; Inf(1))
AP: 2 &quot;a&quot; &quot;b&quot;
--BODY--
State: 0 &quot;a U b&quot; { 0 }
  2  /* !a  &amp; !b */
  0  /*  a  &amp; !b */
  1  /* !a  &amp;  b */
  1  /*  a  &amp;  b */
State: 1 { 1 }
  1 1 1 1       /* four transitions on one line */
State: 2 &quot;sink state&quot; { 0 }
  2 2 2 2
--END--</code></pre>
<h3 id="tgba-with-implicit-labels">TGBA with implicit labels</h3>
<p><img src="figures/aut3.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;GFa &amp; GFb&quot;
States: 1
Start: 0
acc-name: generalized-Buchi 2
Acceptance: 2 (Inf(0) &amp; Inf(1))
AP: 2 &quot;a&quot; &quot;b&quot;
--BODY--
State: 0
  0       /* !a  &amp; !b */
  0 {0}   /*  a  &amp; !b */
  0 {1}   /* !a  &amp;  b */
  0 {0 1} /*  a  &amp;  b */
--END--</code></pre>
<h3 id="tgba-with-explicit-labels">TGBA with explicit labels</h3>
<p><img src="figures/aut3.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;GFa &amp; GFb&quot;
States: 1
Start: 0
acc-name: generalized-Buchi 2
Acceptance: 2 (Inf(0) &amp; Inf(1))
AP: 2 &quot;a&quot; &quot;b&quot;
--BODY--
State: 0
[!0 &amp; !1] 0
[0 &amp; !1]  0 {0}
[!0 &amp; 1]  0 {1}
[0 &amp; 1]   0 {0 1}
--END--</code></pre>
<h3 id="tgba-with-explicit-labels-using-aliases">TGBA with explicit labels using aliases</h3>
<p>The following demonstrates the use of aliases to make the output slightly more readable (using <code>@a</code> instead of <code>0</code>), and to abbreviate commonly used subformulas (<code>@bc</code> instead of <code>1 &amp; 2</code>).</p>
<p><img src="figures/aut4.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;GFa &amp; GF(b &amp; c)&quot;
States: 1
Start: 0
acc-name: generalized-Buchi 2
Acceptance: 2 (Inf(0) &amp; Inf(1))
AP: 3 &quot;a&quot; &quot;b&quot; &quot;c&quot;
Alias: @a 0
Alias: @bc 1 &amp; 2
--BODY--
State: 0
[!@a &amp; !@bc] 0
[@a &amp; !@bc]  0 {0}
[!@a &amp; @bc]  0 {1}
[@a &amp; @bc]   0 {0 1}
--END--</code></pre>
<h3 id="non-deterministic-state-based-buchi-automaton-a-la-wring">Non-deterministic State-based Büchi automaton (à la Wring)</h3>
<p>Encoding <code>GFa</code> using state labels requires multiple initial states.</p>
<p><img src="figures/aut5.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;GFa&quot;
States: 2
Start: 0
Start: 1
acc-name: Buchi
Acceptance: 1 Inf(0)
AP: 1 &quot;a&quot;
--BODY--
State: [0] 0 {0}
  0 1
State: [!0] 1
  0 1
--END--</code></pre>
<p>In this case, the acceptance and labels are carried by the states, so the only information given by the <code>edges</code> lists are the destinations states <code>0 1</code>.</p>
<p>Note that even if a tool has no support for state labels or multiple initial states, the above automaton could easily be transformed into a transition-based one upon reading. It suffices to add a new initial state connected to all the original initial states, and then to move all labels onto incoming transitions. Acceptance sets can be moved to incoming or (more naturally) to outgoing transitions. For instance the following transition-based Büchi automaton is equivalent to the previous example:</p>
<p><img src="figures/aut6.svg" alt="automaton" /></p>
<pre><code>HOA: v1
States: 3
Start: 0
acc-name: Buchi
Acceptance: 1 Inf(0)
AP: 1 &quot;a&quot;
--BODY--
State: 0
 [0] 1
 [!0]  2
State: 1  /* former state 0 */
 [0] 1 {0}
 [!0] 2 {0}
State: 2  /* former state 1 */
 [0] 1
 [!0] 2
--END--</code></pre>
<h3 id="mixing-state-based-and-transition-based-acceptance">Mixing state-based and transition-based acceptance</h3>
<p>Here is a Büchi automaton for <code>GFa | G(b &lt;-&gt; Xa)</code>.</p>
<p><img src="figures/aut7.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;GFa | G(b &lt;-&gt; Xa)&quot;
Start: 0
acc-name: Buchi
Acceptance: 1 Inf(0)
AP: 2 &quot;a&quot; &quot;b&quot;
properties: explicit-labels trans-labels
--BODY--
State: 0
 [t] 1
 [1] 2
 [!1] 3
State: 1 &quot;GFa&quot;
 [0] 1 {0}
 [!0] 1
State: 2 &quot;a &amp; G(b &lt;-&gt; Xa)&quot; {0}
 [0&amp;1] 2
 [0&amp;!1] 3
State: 3 &quot;!a &amp; G(b &lt;-&gt; Xa)&quot; {0}
 [!0&amp;1] 2
 [!0&amp;!1] 3
--END--</code></pre>
<p>In this automaton, marking states 2 and 3 as belonging to set 0<br />is equivalent to marking all their outgoing transitions as such:</p>
<p><img src="figures/aut8.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;GFa | G(b &lt;-&gt; Xa)&quot;
Start: 0
acc-name: Buchi
Acceptance: 1 Inf(0)
AP: 2 &quot;a&quot; &quot;b&quot;
properties: explicit-labels trans-labels trans-acc
--BODY--
State: 0
 [t] 1
 [1] 2
 [!1] 3
State: 1 &quot;GFa&quot;
 [0] 1 {0}
 [!0] 1
State: 2 &quot;a &amp; G(b &lt;-&gt; Xa)&quot;
 [0&amp;1] 2 {0}
 [0&amp;!1] 3 {0}
State: 3 &quot;!a &amp; G(b &lt;-&gt; Xa)&quot;
 [!0&amp;1] 2 {0}
 [!0&amp;!1] 3 {0}
--END--</code></pre>
<p>Mixing state-based and transition-based acceptance can also be done in the same state. For instance a state like:</p>
<p><img src="figures/aut9.svg" alt="automaton" /></p>
<pre><code>State: 1 {1}
 [0] 2
 [!0] 3 {0}</code></pre>
<p>is equivalent to</p>
<p><img src="figures/aut10.svg" alt="automaton" /></p>
<pre><code>State: 1
 [0] 2 {1}
 [!0] 3 {0 1}</code></pre>
<h3 id="alternating-automata">Alternating automata</h3>
<p>Here is an example of alternating transition-based co-Büchi automaton encoding <code>(Fa &amp; G(b&amp;Xc)) | c</code>, it shows an example of multiple initial states (including a conjunct), and an example of conjunct destination.</p>
<p><img src="figures/aut11.svg" alt="automaton" /></p>
<pre><code>HOA: v1
name: &quot;(Fa &amp; G(b&amp;Xc)) | c&quot;
States: 4
Start: 0&amp;2
Start: 3
acc-name: co-Buchi
Acceptance: 1 Fin(0)
AP: 3 &quot;a&quot; &quot;b&quot; &quot;c&quot;
--BODY--
State: 0 &quot;Fa&quot;
[t] 0 {0}
[0] 1
State: 1 &quot;true&quot;
[t] 1
State: 2 &quot;G(b&amp;Xc)&quot;
[1] 2&amp;3
State: 3 &quot;c&quot;
[2] 1
--END--</code></pre>
<h2 id="formal-semantics-of-omega-automata">Formal Semantics of Omega-Automata</h2>
<p>The following definition specifies alternating automata with transition-based acceptance. Because of universal branching, the initial states and destination states of transitions are non-empty sets of states (i.e., elements of <span class="math">\(2^Q\setminus\{\emptyset\}\)</span>) interpreted as conjunctions. Automata without universal branching use just elements of Q as initial or destination states.</p>
<p>Each omega-automaton described in this format can be seen as an automaton <span class="math">\(\langle\AP,Q,R,I,F,\mathit{Acc}\rangle\)</span> with labels on transitions and transition-based acceptance, where:</p>
<ul>
<li><span class="math">\(\AP\)</span> is a finite set of atomic propositions. We use <span class="math">\(\B(\AP)\)</span> to denote the set of Boolean formulas over <span class="math">\(\AP\)</span>.</li>
<li><span class="math">\(Q\)</span> is a finite set of states.</li>
<li><span class="math">\(R\subseteq Q\times\B(\AP)\times 2^{\{0,1,\ldots,m-1\}}\times(2^Q\setminus\{\emptyset\})\)</span> is a transition relation. A quadruplet <span class="math">\((s,\ell,M,D)\in R\)</span> represents a transition from <span class="math">\(s\)</span> to the conjunction of states in <span class="math">\(D\)</span>, labeled by a Boolean formula <span class="math">\(\ell\in\B(\AP)\)</span>, and belonging to the acceptance sets listed in <span class="math">\(M\subseteq \{0,1,\ldots,m-1\}\)</span>, where <span class="math">\(m\)</span> is the declared number of acceptance sets.</li>
<li><span class="math">\(I\subseteq(2^Q\setminus\{\emptyset\})\)</span> is a set of initial conjunctions of states.</li>
<li><span class="math">\(F=\{S_0,S_1,\ldots,S_{m-1}\}\)</span> is a finite set of acceptance sets. Each acceptance set <span class="math">\(S_i = \{ (s,\ell,M,D)\in R \mid i\in M \}\)</span> is a subset of <strong>transitions</strong>.</li>
<li><span class="math">\(\mathit{Acc}\)</span> is a Boolean formula over <span class="math">\(\{\Fin(i),\Fin(\lnot i),\Inf(i),\Inf(\lnot i)\mid i\in \{0,1,\ldots,m-1\}\}\)</span>.</li>
</ul>
<p>The automaton is interpreted over infinite words, where letters are subsets of <span class="math">\(\AP\)</span>. A <strong>run</strong> over a word <span class="math">\(w=a_0 a_1\ldots\)</span> is an infinite labeled directed acyclic graph <span class="math">\((V,E,\lambda)\)</span> such that:</p>
<ul>
<li><span class="math">\(V\)</span> is partitioned into <span class="math">\(V_0\cup V_₁\cup V_2\ldots\)</span> where the sets <span class="math">\(V_i\)</span> are disjoint,</li>
<li>for each edge <span class="math">\(e\in E\)</span> there exists <span class="math">\(i\ge 0\)</span> such that <span class="math">\(e\in V_i\times V_{i+1}\)</span>,</li>
<li><span class="math">\(\lambda:V\to Q\)</span> is a labeling function such that <span class="math">\(\{\lambda(x)\mid x\in V_0\}\in I\)</span> and for each <span class="math">\(x\in V_i\)</span> there exists a transition <span class="math">\((\lambda(x),\ell_i,\{\lambda(y)\mid (x,y)\in E\})\in R\)</span> such that <span class="math">\(\ell_i\)</span> evaluates to True in the valuation assigning True to atomic propositions in <span class="math">\(a_i\)</span> and False to all other atomic propositions. We say that the transition <span class="math">\((\lambda(x),\ell_i,\{\lambda(y)\mid(x,y)\in E\})\)</span> is <strong>applied to</strong> <span class="math">\(x\)</span>.</li>
</ul>
<p>Runs of automata without universal branching are simply infinite linear sequences of nodes.</p>
<p>A run is <strong>accepting</strong> if each branch of the run (i.e., each infinite oriented path starting in <span class="math">\(V_0\)</span>) satisfies the acceptance condition <span class="math">\(\mathit{Acc}\)</span>, where a branch satisfies</p>
<ul>
<li><span class="math">\(\Fin(i)\)</span> if all transitions in <span class="math">\(S_i\)</span> are applied only to finitely many nodes on the branch.</li>
<li><span class="math">\(\Fin(\lnot i)\)</span> if all transitions outside <span class="math">\(S_i\)</span> are applied only to finitely many nodes on the branch.</li>
<li><span class="math">\(\Inf(i)\)</span> if some transition in <span class="math">\(S_i\)</span> is applied to infinitely many nodes on the branch.</li>
<li><span class="math">\(\Inf(\lnot i)\)</span> if some transition outside <span class="math">\(S_i\)</span> is applied to infinitely many nodes on the branch.</li>
</ul>
<p>The automaton recognizes the language of all words for which there exists an accepting run of the automaton.</p>
<p>As mentioned above, the format also supports labels on states. This is formally seen as an abbreviation for the situation where all transitions leaving the state have this label. The format even admits automata combining states with labels, unlabeled states with labels on all outgoing transitions, and unlabeled states with implicitly labeled transitions.</p>
<p>The format supports both state-based and transition-based acceptance sets. In our transition-based semantics, as illustrated by our previous examples, marking a state as belonging to some acceptance set with (for instance) <code>State: 0 {1 3}</code> is syntactic sugar for marking all the outgoing transitions of state 0 as belonging to acceptance sets 1 and 3. This is especially important if one combines states and transitions in an acceptance set and use negation of this acceptance sets in the acceptance condition.</p>
<h2 id="semantics-for-pure-state-based-acceptance">Semantics for Pure State-Based Acceptance</h2>
<p>In tools that manipulate only state-based acceptance, acceptance will only be used for states, and therefore the transition-based semantics are inconvenient. For these tools, one can consider the following semantics.</p>
<p>The omega-automata are represented by a tuple <span class="math">\(\langle\AP,Q,R,I,F,\mathit{Acc}\rangle\)</span>, where:</p>
<ul>
<li><span class="math">\(\AP\)</span> is a finite set of atomic propositions.</li>
<li><span class="math">\(Q\)</span> is a finite set of states.</li>
<li><span class="math">\(R\subseteq Q\times\B(\AP)\times(2^Q\setminus\{\emptyset\})\)</span> is a transition relation,</li>
<li><span class="math">\(I\subseteq(2^Q\setminus\{\emptyset\})\)</span> is a set of initial conjunctions of states,</li>
<li><span class="math">\(F=\{S_0,S_1,\ldots,S_{m-1}\}\)</span> is a finite set of acceptance sets. Each acceptance set <span class="math">\(S_i\subseteq Q\)</span> is a subset of <strong>states</strong>.</li>
<li><span class="math">\(\mathit{Acc}\)</span> is an acceptance condition.</li>
</ul>
<p>The only difference with the transition-based definition is that <span class="math">\(S_i\subseteq Q\)</span> instead of <span class="math">\(S_i\subseteq R\)</span>. The acceptance condition is still a formula defined over <span class="math">\(\Fin(i)\)</span>, <span class="math">\(\Fin(\lnot i)\)</span>, <span class="math">\(\Inf(i)\)</span>, or <span class="math">\(\Inf(\lnot i)\)</span>, but this time each <span class="math">\(i\)</span> refers to the set <span class="math">\(S_i\)</span> of <strong>states</strong> that must occur infinitely or finitely often on each branch of an accepting run, and the complement operation <span class="math">\(\lnot\)</span> should be done with respect to <span class="math">\(Q\)</span> instead of <span class="math">\(R\)</span>.</p>
<p>An automaton with state-based acceptance can be trivially converted to transition-based acceptance by shifting the acceptance set membership from each state to its outgoing transitions, and the two semantics are compatible in the sense that the two automata would recognize the same language. If the automaton has no dead states (i.e., states without successor), the result of such transformation can easily be reversed.</p>
<p>The two semantics disagree slightly on the handling of dead states. The state-based semantics allow dead states to appear in acceptance sets, while there is no way to do that with transition-based acceptance. This difference is inconsequential: a dead state is never going to contribute anything useful the recognized language.</p>
<h2 id="authors">Authors</h2>
<p>This document has been put together by the following people:</p>
<ul>
<li>Alexandre Duret-Lutz</li>
<li>František Blahoudek</li>
<li>Jan Křetínský</li>
<li>Jan Strejček</li>
<li>Joachim Klein</li>
</ul>
</body>
</html>
